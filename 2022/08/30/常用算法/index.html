
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>常用算法 - 刘杨杨的个人博客</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="lyy,"> 
    <meta name="description" content="刘杨杨,##二叉树递归遍历的三种姿势以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：

先序遍历
中序遍历
后序遍历
层次遍历

按照实现方式的,"> 
    <meta name="author" content="刘杨杨"> 
    <link rel="alternative" href="atom.xml" title="刘杨杨的个人博客" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
    
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:title" content="常用算法 - 刘杨杨的个人博客"/>
    <meta name="twitter:description" content="刘杨杨,##二叉树递归遍历的三种姿势以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：

先序遍历
中序遍历
后序遍历
层次遍历

按照实现方式的,"/>
    
    
    
    
    <meta property="og:site_name" content="刘杨杨的个人博客"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="常用算法 - 刘杨杨的个人博客"/>
    <meta property="og:description" content="刘杨杨,##二叉树递归遍历的三种姿势以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：

先序遍历
中序遍历
后序遍历
层次遍历

按照实现方式的,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

    <script>window.searchDbPath = "/search.xml";</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<meta name="generator" content="Hexo 5.4.2"></head>

<body class="loading">
    <span id="config-title" style="display:none">刘杨杨的个人博客</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://miemie137.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">常用算法</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">常用算法</h1>
        <div class="stuff">
            <span>八月 30, 2022</span>
            

        </div>
        <div class="content markdown">
            <p>##二叉树递归遍历的三种姿势<br>以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
<p>按照实现方式的不同，遍历方式又可以分为以下两种：</p>
<ul>
<li>递归遍历（先、中、后序遍历）</li>
<li>迭代遍历（层次遍历）</li>
</ul>
<p>遍历的可能顺序也不过三种：</p>
<ul>
<li>根结点 -&gt; 左子树 -&gt; 右子树</li>
<li>左子树 -&gt; 根结点 -&gt; 右子树</li>
<li>左子树 -&gt; 右子树 -&gt; 根结点</li>
</ul>
<p>上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。</p>
<p>在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。<br>所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。</p>
<p><strong>先序遍历的编码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有遍历函数的入参都是树的根结点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">preorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有遍历函数的入参都是树的根结点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##数组的应用<br>###Map 的妙用——两数求和问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">示例: 给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span> 所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>大家以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。</p>
<p>大家记住一个结论：几乎所有的求和问题，都可以转化为求差问题。 这道题就是一个典型的例子，通过把求和问题转化为求差问题，事情会变得更加简单。</p>
<p><strong>我们可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的差值是否已经在前面的数字中出现过了</strong>。若出现过，那么答案已然显现，我们就不必再往下走了。</p>
<p><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_6.png" alt="img_6.png"><br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_7.png" alt="img_7.png"><br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_8.png" alt="img_8.png"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里我用对象来模拟 map 的能力</span></span><br><span class="line">    <span class="keyword">const</span> diffs = &#123;&#125;</span><br><span class="line">    <span class="comment">// 缓存数组长度</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="comment">// 判断当前值对应的 target 差值是否存在（是否已遍历过）</span></span><br><span class="line">        <span class="keyword">if</span>(diffs[target-nums[i]]!==<span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="comment">// 若有对应差值，那么答案get！</span></span><br><span class="line">            <span class="keyword">return</span> [diffs[target - nums[i]], i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若没有对应差值，则记录当前值</span></span><br><span class="line">        diffs[nums[i]]=i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>###强大的双指针法<br>####合并两个有序数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例: 输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>这道题没有太多的弯弯绕绕，标准解法就是双指针法。首先我们定义两个指针，各指向两个数组生效部分的尾部：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_9.png" alt="img_9.png"><br>每次只对指针所指的元素进行比较。取其中较大的元素，把它从 nums1 的末尾往前面填补：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_10.png" alt="img_10.png"></p>
<p>由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个提前到头的这种情况：</p>
<ul>
<li><p>如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。</p>
</li>
<li><p>如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是 nums1，所以此时不必做任何额外的操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span></span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 当两个数组都没遍历完时，指针同步移动</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 取较大的值，从末尾往前填补</span></span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">            nums1[k] = nums1[i] </span><br><span class="line">            i-- </span><br><span class="line">            k--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j] </span><br><span class="line">            j-- </span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums2 留下的情况，特殊处理一下 </span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        nums1[k] = nums2[j]  </span><br><span class="line">        k-- </span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><em>个人总结：</em>*</p>
</li>
<li><p>nums1后面留出足够塞nums2的length（3）的空位</p>
</li>
<li><p>两个数组尾部比较，6&gt;3,6塞在nums1最后，nums2往前进一位，nums1总长度往前进一位</p>
</li>
<li><p>继续尾部比较，5&gt;3，6塞在nums1倒数第二位，nums2往前进一位，nums1总长度往前进一位</p>
</li>
<li><p>继续尾部比较，2&lt;3，3塞在nums1倒数第三位，nums1往前进一位，nums1总长度往前进一位<br>…以此类推</p>
</li>
</ul>
<p>####三数求和问题</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = <span class="number">0</span> ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例： 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]， 满足要求的三元组集合为： [ [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>] ]</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>把求和问题变成求差问题——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的</p>
<p><strong>双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。</strong>否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> nums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_11.png" alt="img_11.png"></p>
<p>每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：</p>
<ul>
<li><p>相加之和大于0，说明右侧的数偏大了，右指针左移</p>
</li>
<li><p>相加之和小于0，说明左侧的数偏小了，左指针右移</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 用于存放结果数组</span></span><br><span class="line">    <span class="keyword">let</span> res = [] </span><br><span class="line">    <span class="comment">// 给 nums 排序</span></span><br><span class="line">    nums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 缓存数组长度</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 左指针 j</span></span><br><span class="line">        <span class="keyword">let</span> j=i+<span class="number">1</span> </span><br><span class="line">        <span class="comment">// 右指针k</span></span><br><span class="line">        <span class="keyword">let</span> k=len-<span class="number">1</span>   </span><br><span class="line">        <span class="comment">// 如果遇到重复的数字，则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]===nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;k) &#123;</span><br><span class="line">            <span class="comment">// 三数之和小于0，左指针前进</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                j++</span><br><span class="line">               <span class="comment">// 处理左指针元素重复的情况</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 三数之和大于0，右指针后退</span></span><br><span class="line">                k--</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 处理右指针元素重复的情况</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                    k--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 得到目标数字组合，推入结果数组</span></span><br><span class="line">                res.<span class="title function_">push</span>([nums[i],nums[j],nums[k]])</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 左右指针一起前进</span></span><br><span class="line">                j++  </span><br><span class="line">                k--</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 若左指针元素重复，跳过</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;  </span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 若右指针元素重复，跳过</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                    k--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>什么时候你需要联想到对撞指针？<br>这里我给大家两个关键字——“有序”和“数组”。<br>没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！</p>
<p>##字符串的应用<br>###判断一个字符串是否是回文字符串<br><strong>重点：对称性</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</span><br></pre></td></tr></table></figure>
<p>思路：字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——对称性 和 双指针。这两个工具一起上，足以解决大部分的回文字符串衍生问题。</p>
<p>回到这道题上来，我们首先是初始化两个指针，一个指向字符串头部，另一个指向尾部：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_12.png" alt="img_12.png"><br>如果两个指针所指的字符恰好相等，那么这两个字符就符合了回文字符串对对称性的要求，跳过它们往下走即可。如果两个指针所指的字符串不等，比如这样：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_13.png" alt="img_13.png"><br>那么就意味着不对称发生了，意味着这是一个可以“删掉试试看”的操作点。我们可以分别对左指针字符和右指针字符尝试进行“跳过”，看看区间在 [left+1, right] 或 [left, right-1] 的字符串是否回文。如果是的话，那么就意味着如果删掉被“跳过”那个字符，整个字符串都将回文：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_14.png" alt="img_14.png"><br>比如说这里我们跳过了 b，[left+1, right] 的区间就是 [2, 2]，它对应 c 这个字符，单个字符一定回文。这样一来，删掉 b 之后，左右指针所指的内部区间是回文的，外部区间也是回文的，可以认为整个字符串就是一个回文字符串了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> validPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存字符串的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i、j分别为左右指针</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>, j=len-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右指针均满足对称时，一起向中间前进</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j&amp;&amp;s[i]===s[j]) &#123;</span><br><span class="line">        i++ </span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试判断跳过左指针元素后字符串是否回文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isPalindrome</span>(i+<span class="number">1</span>,j)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试判断跳过右指针元素后字符串是否回文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isPalindrome</span>(i,j-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 工具方法，用于判断字符串是否回文</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">st, ed</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(st&lt;ed) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[st] !== s[ed]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            st++</span><br><span class="line">            ed--</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>##链表的应用<br>###链表的合并</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。 </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例： 输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span> 输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>做链表处理类问题，大家要把握住一个中心思想——处理链表的本质，是处理链表结点之间的指针关系。<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_15.png" alt="img_15.png"></p>
<p>这根针每次钻进扣子眼儿之前，要先比较一下它眼前的两个扣子，选择其中值较小的那个，优先把它串进去。一次串一个，直到所有的扣子都被串进一条线为止（下图中红色箭头表明穿针的过程与方向）：</p>
<p><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_16.png" alt="img_16.png"><br>同时我们还要考虑 l1 和 l2 两个链表长度不等的情况：若其中一个链表已经完全被串进新链表里了，而另一个链表还有剩余结点，考虑到该链表本身就是有序的，我们可以直接把它整个拼到目标链表的尾部。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义头结点，确保链表可以被访问到</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">  <span class="comment">// cur 这里就是咱们那根“针”</span></span><br><span class="line">  <span class="keyword">let</span> cur = head</span><br><span class="line">  <span class="comment">// “针”开始在 l1 和 l2 间穿梭了</span></span><br><span class="line">  <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">      <span class="comment">// 如果 l1 的结点值较小</span></span><br><span class="line">      <span class="keyword">if</span>(l1.<span class="property">val</span>&lt;=l2.<span class="property">val</span>) &#123;</span><br><span class="line">          <span class="comment">// 先串起 l1 的结点</span></span><br><span class="line">          cur.<span class="property">next</span> = l1</span><br><span class="line">          <span class="comment">// l1 指针向前一步</span></span><br><span class="line">          l1 = l1.<span class="property">next</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// l2 较小时，串起 l2 结点</span></span><br><span class="line">          cur.<span class="property">next</span> = l2</span><br><span class="line">          <span class="comment">// l2 向前一步</span></span><br><span class="line">          l2 = l2.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// “针”在串起一个结点后，也会往前一步</span></span><br><span class="line">      cur = cur.<span class="property">next</span> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理链表不等长的情况</span></span><br><span class="line">  cur.<span class="property">next</span> = l1!==<span class="literal">null</span>?<span class="attr">l1</span>:l2</span><br><span class="line">  <span class="comment">// 返回起始结点</span></span><br><span class="line">  <span class="keyword">return</span> head.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###链表结点的删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真题描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>将需要删除的目标结点的前驱结点 next 指针往后指一格：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_17.png" alt="img_17.png"><br>判断两个元素是否重复，由于此处是已排序的链表，我们直接判断前后两个元素值是否相等即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 设定 cur 指针，初始位置为链表第一个结点</span></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.<span class="property">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若当前结点和它后面一个结点值相等（重复）</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除靠后的那个结点（去重）</span></span><br><span class="line">            cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若不重复，继续遍历</span></span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###删除问题的延伸——dummy 结点登场</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>咱们要做的事情变成了把前驱和后继一起删掉，前面两个值为1的结点要一起狗带才行，起始结点直接变成了第三个：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_18.png" alt="img_18.png"><br>其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 dummy 结点来解决这个问题。</p>
<p>回到这道题上来，我们首先要做的就是定义一个 dummy 结点，指向链表的起始位置：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_19.png" alt="img_19.png"><br>这样一来，如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_20.png" alt="img_20.png"></p>
<p>注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 极端情况：0个或1个结点，则不会重复，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dummy 登场</span></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>() </span><br><span class="line">    <span class="comment">// dummy 永远指向头结点</span></span><br><span class="line">    dummy.<span class="property">next</span> = head   </span><br><span class="line">    <span class="comment">// cur 从 dummy 开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> cur = dummy </span><br><span class="line">    <span class="comment">// 当 cur 的后面有至少两个结点时</span></span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="comment">// 对 cur 后面的两个结点进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">            <span class="keyword">let</span> val = cur.<span class="property">next</span>.<span class="property">val</span></span><br><span class="line">            <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">val</span>===val) &#123;</span><br><span class="line">                <span class="comment">// 若有，则删除</span></span><br><span class="line">                cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">            cur = cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回链表的起始结点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="http://link.hhtjim.com/163/425570952.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
        
    <div id="gitalk-container" class="comment link"
		data-enable="false"
        data-ae="false"
        data-ci=""
        data-cs=""
        data-r=""
        data-o=""
        data-a=""
        data-d="false"
    >查看评论</div>


    </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
