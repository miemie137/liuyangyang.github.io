<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript思维导图</title>
    <url>/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="JS思维导图汇总"><a href="#JS思维导图汇总" class="headerlink" title="JS思维导图汇总"></a>JS思维导图汇总</h1><hr>
<h2 id="1-JavaScript变量"><a href="#1-JavaScript变量" class="headerlink" title="1.JavaScript变量"></a>1.JavaScript变量</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031424088288890.gif"></p>
<h2 id="2-JavaScript运算符"><a href="#2-JavaScript运算符" class="headerlink" title="2.JavaScript运算符"></a>2.JavaScript运算符</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031425524532800.gif"></p>
<h2 id="3-JavaScript数组"><a href="#3-JavaScript数组" class="headerlink" title="3.JavaScript数组"></a>3.JavaScript数组</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031426347503011.gif"></p>
<h2 id="4-JavaScript流程语句"><a href="#4-JavaScript流程语句" class="headerlink" title="4.JavaScript流程语句"></a>4.JavaScript流程语句</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031427375004707.gif"></p>
<h2 id="5-JavaScript字符串函数"><a href="#5-JavaScript字符串函数" class="headerlink" title="5.JavaScript字符串函数"></a>5.JavaScript字符串函数</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031428564386592.gif"></p>
<h2 id="6-JavaScript函数基础"><a href="#6-JavaScript函数基础" class="headerlink" title="6.JavaScript函数基础"></a>6.JavaScript函数基础</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031429317505536.gif"></p>
<h2 id="7-JavaScript基础DOM操作"><a href="#7-JavaScript基础DOM操作" class="headerlink" title="7.JavaScript基础DOM操作"></a>7.JavaScript基础DOM操作</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031430098606493.gif"><br><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/291310116771993.jpg"></p>
<h2 id="8-JavaScript基础BOM操作"><a href="#8-JavaScript基础BOM操作" class="headerlink" title="8.JavaScript基础BOM操作"></a>8.JavaScript基础BOM操作</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/291311256619962.jpg"></p>
<h2 id="9-JavaScript正则表达式"><a href="#9-JavaScript正则表达式" class="headerlink" title="9.JavaScript正则表达式"></a>9.JavaScript正则表达式</h2><p><img src="/2020/06/28/javascript%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/031430427829068.gif"></p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Js继承</title>
    <url>/2022/08/30/Js%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>##继承<br>###JavaScript常见的继承方式：</p>
<ul>
<li>原型链继承</li>
<li>构造函数继承（借助 call）</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
<li>原型链继承</li>
</ul>
<p>####原型链继承<br>是比较常见的继承方式之一，其中涉及的构造函数、原型和实例，三者之间存在着一定的关系，即每一个构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针 </p>
<p><font color="red">问题：两个实例使用的是同一个原型对象，内存空间是共享的</font></p>
<p>####构造函数继承</p>
<p>借助 call调用Parent函数</p>
<p>可以看到，父类原型对象中一旦存在父类之前自己定义的方法，那么子类将无法继承这些方法</p>
<p><font color="red">问题:相比第一种原型链继承方式，父类的引用属性不会被共享，优化了第一种继承方式的弊端，但是只能继承父类的实例属性和方法，不能继承原型属性或者方法</font></p>
<p>####组合继承</p>
<p>前面我们讲到两种继承方式，各有优缺点。组合继承则将前两种方式继承起来</p>
<p><font color="red">问题：这种方式看起来就没什么问题，方式一和方式二的问题都解决了，但是从上面代码我们也可以看到Parent3 执行了两次，造成了多构造一次的性能开销</font></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一次调用 Parent3()  </span></span><br><span class="line"><span class="title class_">Child3</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent3</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child3</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// 第二次调用 Parent3()</span></span><br><span class="line">    <span class="title class_">Parent3</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = <span class="string">&#x27;child3&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>####原型式继承<br>这里主要借助Object.create方法实现普通对象的继承</p>
<p><font color="red">问题：这种继承方式的缺点也很明显，因为Object.create方法实现的是浅拷贝，多个实例的引用类型属性指向相同的内存，存在篡改的可能</font><br>####寄生式继承<br>寄生式继承在上面继承基础上进行优化，利用这个浅拷贝的能力再进行增强，添加一些方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> parent5 = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;parent5&quot;</span>,</span><br><span class="line">    <span class="attr">friends</span>: [<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;p2&quot;</span>, <span class="string">&quot;p3&quot;</span>],</span><br><span class="line">    <span class="attr">getName</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">original</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(original);</span><br><span class="line">    clone.<span class="property">getFriends</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> clone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person5 = <span class="title function_">clone</span>(parent5);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getName</span>()); <span class="comment">// parent5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person5.<span class="title function_">getFriends</span>()); <span class="comment">// [&quot;p1&quot;, &quot;p2&quot;, &quot;p3&quot;]</span></span><br></pre></td></tr></table></figure>
<p>其优缺点也很明显，跟上面讲的原型式继承一样<br>####寄生组合式继承<br>寄生组合式继承，借助解决普通对象的继承问题的Object.create 方法，在几种继承方式的优缺点基础上进行改造，这也是所有继承方式里面相对最优的继承方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span> (parent, child) &#123;</span><br><span class="line">    <span class="comment">// 这里改用 Object.create 就可以减少组合继承中多进行一次构造的过程</span></span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent6</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;parent6&#x27;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">play</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child6</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Parent6</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">friends</span> = <span class="string">&#x27;child5&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">clone</span>(<span class="title class_">Parent6</span>, <span class="title class_">Child6</span>);</span><br><span class="line"><span class="title class_">Child6</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getFriends</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">friends</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person6 = <span class="keyword">new</span> <span class="title class_">Child6</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6); <span class="comment">//&#123;friends:&quot;child5&quot;,name:&quot;child5&quot;,play:[1,2,3],__proto__:Parent6&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getName</span>()); <span class="comment">// parent6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person6.<span class="title function_">getFriends</span>()); <span class="comment">// child5</span></span><br><span class="line"></span><br><span class="line">可以看到 person6 打印出来的结果，属性都得到了继承，方法也没问题</span><br><span class="line">文章一开头，我们是使用<span class="title class_">ES6</span> 中的<span class="keyword">extends</span>关键字直接实现 <span class="title class_">JavaScript</span>的继承</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 原型方法</span></span><br><span class="line">    <span class="comment">// 即 Person.prototype.getName = function() &#123; &#125;</span></span><br><span class="line">    <span class="comment">// 下面可以简写为 getName() &#123;...&#125;</span></span><br><span class="line">    getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Person:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gamer</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="comment">// 子类中存在构造函数，则需要在使用“this”之前首先调用 super()。</span></span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> asuna = <span class="keyword">new</span> <span class="title class_">Gamer</span>(<span class="string">&#x27;Asuna&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">asuna.<span class="title function_">getName</span>() <span class="comment">// 成功访问到父类的方法</span></span><br></pre></td></tr></table></figure>
<p>利用babel工具进行转换，我们会发现extends实际采用的也是寄生组合继承方式，因此也证明了这种方式是较优的解决继承的方式<br>###总结</p>
<p>下面以一张图作为总结：<br><img src="/2022/08/30/Js%E7%BB%A7%E6%89%BF/jicheng.png" alt="assets/img/jicheng.png"><br>通过Object.create 来划分不同的继承方式，最后的寄生式组合继承方式是通过组合继承改造之后的最优继承方式，而 extends 的语法糖和寄生组合继承的方式基本类似</p>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx</title>
    <url>/2022/08/30/Nginx/</url>
    <content><![CDATA[<p>##Nginx<br>###Nginx的产生<br>Nginx 同 Apache 一样都是一种 <strong>Web 服务器</strong>。基于 REST 架构风格，以统一资源描述符（Uniform Resources Identifier）URI 或者统一资源定位符（Uniform Resources Locator）URL 作为沟通依据，通过 HTTP 协议提供各种网络服务。<br>然而，这些服务器在设计之初受到当时环境的局限，例如当时的用户规模，网络带宽，产品特点等局限并且各自的定位和发展都不尽相同。这也使得各个 Web 服务器有着各自鲜明的特点。<br>Apache 的发展时期很长，而且是毫无争议的世界第一大服务器。它有着很多优点：稳定、开源、跨平台等等。<br>它出现的时间太长了，它兴起的年代，互联网产业远远比不上现在。所以它被设计为一个重量级的。<br>它不支持高并发的服务器。在 Apache 上运行数以万计的并发访问，会导致服务器消耗大量内存。<br>操作系统对其进行进程或线程间的切换也消耗了大量的 CPU 资源，导致 HTTP 请求的平均响应速度降低。<br>这些都决定了 Apache 不可能成为高性能 Web 服务器，<strong>轻量级高并发服务器 Nginx 就应运而生了</strong>。</p>
<p>由于以下这几点，所以，Nginx 火了：</p>
<ul>
<li><p>Nginx 使用基于事件驱动架构，使得其可以支持数以百万级别的 TCP 连接。</p>
</li>
<li><p>高度的模块化和自由软件许可证使得第三方模块层出不穷。</p>
</li>
<li><p>Nginx 是一个跨平台服务器，可以运行在 Linux、Windows、FreeBSD、Solaris、AIX、Mac OS 等操作系统上。</p>
</li>
</ul>
<p>###Nginx 基本概念<br>####1、正向代理与反向代理<br>nginx是一个高性能的反向代理服务器,那么什么是反向代理呢？</p>
<p><strong>代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。</strong></p>
<p>不管是正向代理还是反向代理，实现的都是上面的功能。</p>
<p>如果你对OSI 七层模型与 TCP/IP 四层模型不是很熟悉可以再回顾下</p>
<p><img src="/2022/08/30/Nginx/nginx_1.png" alt="assets/img/nginx_1.png"></p>
<p>#####正向代理<br>正向代理（forward）意思是一个位于客户端和原始服务器 (origin server) 之间的服务器，</p>
<p>为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标 (原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>
<p>正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。</p>
<p>正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。</p>
<p>#####反向代理<br>反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<p>反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。</p>
<p>反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。</p>
<p>####2、负载均衡<br>如果请求数过大，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器的情况改为请求分发到多个服务器上，就是负载均衡。</p>
<p>Upstream 指定后端服务器地址列表，在 server 中拦截响应请求，并将请求转发到 Upstream 中配置的服务器列表。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">upstream balanceServer &#123;</span><br><span class="line">server <span class="number">10.1</span><span class="number">.22</span><span class="number">.33</span>:<span class="number">12345</span>;</span><br><span class="line">server <span class="number">10.1</span><span class="number">.22</span><span class="number">.34</span>:<span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    server <span class="number">10.1</span><span class="number">.22</span><span class="number">.35</span>:<span class="number">12345</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">server_name  fe.<span class="property">server</span>.<span class="property">com</span>;</span><br><span class="line">listen <span class="number">80</span>;</span><br><span class="line">location /api &#123;</span><br><span class="line">proxy_pass <span class="attr">http</span>:<span class="comment">//balanceServer;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的配置只是指定了 nginx 需要转发的服务端列表，并没有指定分配策略。</p>
<p>默认情况下采用的是轮询策略，将所有客户端请求轮询分配给服务端。这种策略是可以正常工作的，但是如果其中某一台服务器压力太大，出现延迟，会影响所有分配在这台服务器下的用户。</p>
<p>Nginx支持的负载均衡调度算法方式如下：</p>
<p>weight轮询(默认，常用)：接收到的请求按照权重分配到不同的后端服务器，即使在使用过程中，某一台后端服务器宕机，Nginx会自动将该服务器剔除出队列，请求受理情况不会受到任何影响。这种方式下，可以给不同的后端服务器设置一个权重值(weight)，用于调整不同的服务器上请求的分配率；权重数据越大，被分配到请求的几率越大；该权重值，主要是针对实际工作环境中不同的后端服务器硬件配置进行调整的。ip_hash（常用）：每个请求按照发起客户端的ip的hash结果进行匹配，这样的算法下一个固定ip地址的客户端总会访问到同一个后端服务器，这也在一定程度上解决了集群部署环境下session共享的问题。</p>
<p>fair：智能调整调度算法，动态的根据后端服务器的请求处理到响应的时间进行均衡分配，响应时间短处理效率高的服务器分配到请求的概率高，响应时间长处理效率低的服务器分配到的请求少；结合了前两者的优点的一种调度算法。但是需要注意的是Nginx默认不支持fair算法，如果要使用这种调度算法，请安装upstream_fair模块。url_hash：按照访问的url的hash结果分配请求，每个请求的url会指向后端固定的某个服务器，可以在Nginx作为静态服务器的情况下提高缓存效率。同样要注意Nginx默认不支持这种调度算法，要使用的话需要安装Nginx的hash软件包。</p>
<p>####3、动静分离<br>为了加快服务器的解析速度，可以把动态页面和静态页面交给不同的服务器来解析，加快解析速度，降低原来单个服务器的压力。</p>
<p>####4、Nginx常用命令</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 快速关闭<span class="title class_">Nginx</span>，可能不保存相关信息，并迅速终止web服务</span><br><span class="line">nginx -s stop</span><br><span class="line"># 平稳关闭<span class="title class_">Nginx</span>，保存相关信息，有安排的结束web服务</span><br><span class="line">nginx -s quit</span><br><span class="line"># 因改变了<span class="title class_">Nginx</span>相关配置，需要重新加载配置而重载</span><br><span class="line">nginx -s reload</span><br><span class="line"># 重新打开日志文件</span><br><span class="line">nginx -s reopen</span><br><span class="line"># 为 <span class="title class_">Nginx</span> 指定一个配置文件，来代替缺省的</span><br><span class="line">nginx -c filename</span><br><span class="line"># 不运行，而仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件</span><br><span class="line">nginx -t</span><br><span class="line">#  显示 nginx 的版本</span><br><span class="line">nginx -v</span><br><span class="line"># 显示 nginx 的版本，编译器版本和配置参数</span><br><span class="line">nginx -V</span><br><span class="line"># 格式换显示 nginx 配置参数</span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> nginx -V | xargs -n1</span><br><span class="line"><span class="number">2</span>&gt;&amp;<span class="number">1</span> nginx -V | xargs -n1 | grep lua</span><br></pre></td></tr></table></figure>
<p>###为什么选择Nginx<br>Nginx是一款自由的、开源的、高性能的HTTP服务器和反向代理服务器；同时也是一个IMAP、POP3、SMTP代理服务器；Nginx可以作为一个HTTP服务器进行网站的发布处理，另外Nginx可以作为反向代理进行负载均衡的实现。在Nginx网站上，其功能包括：</p>
<ul>
<li><p>HTTP和HTTPS（TLS / SSL / SNI）</p>
</li>
<li><p>超快速的Web服务器用于静态内容</p>
</li>
<li><p>FastCGI，WSGI，SCGI用于动态内容</p>
</li>
<li><p>具有负载平衡和缓存功能的加速Web代理</p>
</li>
<li><p>不间断实时二进制升级和配置</p>
</li>
<li><p>压缩和内容过滤器</p>
</li>
<li><p>虚拟主机</p>
</li>
<li><p>FLV和MP4的媒体流</p>
</li>
<li><p>带宽和连接策略</p>
</li>
<li><p>全面的访问控制</p>
</li>
<li><p>自定义日志</p>
</li>
<li><p>嵌入式脚本</p>
</li>
<li><p>带有TLS的SMTP / IMAP / POP3的邮件代理</p>
</li>
<li><p>逻辑，灵活，可扩展的配置</p>
</li>
<li><p>在Linux，FreeBSD，Mac OS X，Solaris和Windows上运行</p>
</li>
</ul>
<p>###Nginx有如下优势：<br>1、IO多路复用epoll（IO复用）</p>
<p>有A、B、C三个老师，他们都遇到一个难题，要帮助一个班级的学生解决课堂作业。</p>
<p>老师A采用从第一排开始一个学生一个学生轮流解答的方式去回答问题，老师A浪费了很多时间，并且有的学生作业还没有完成呢，老师就来了，反反复复效率极慢。</p>
<p>老师B是一个忍者，他发现老师A的方法行不通，于是他使用了影分身术，分身出好几个自己同一时间去帮好几个同学回答问题，最后还没回答完，老师B消耗光了能量累倒了。</p>
<p>老师C比较精明，他告诉学生，谁完成了作业举手，有举手的同学他才去指导问题，他让学生主动发声，分开了“并发”。</p>
<p>这个老师C就是Nginx。</p>
<p>2、轻量级</p>
<p>功能模块少 - Nginx仅保留了HTTP需要的模块，其他都用插件的方式，后天添加</p>
<p>代码模块化 - 更适合二次开发，如阿里巴巴Tengine</p>
<p>3、CPU亲和</p>
<p>把CPU核心和Nginx工作进程绑定，把每个worker进程固定在一个CPU上执行，减少切换CPU的cache miss，从而提高性能。</p>
<p>###Nginx配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#打开主配置文件，若你是用lnmp环境安装</span><br><span class="line">vim /usr/local/nginx/conf/nginx.<span class="property">conf</span></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">user                    #设置nginx服务的系统使用用户</span><br><span class="line">worker_processes        #工作进程数 一般情况与<span class="variable constant_">CPU</span>核数保持一致</span><br><span class="line">error_log               #nginx的错误日志</span><br><span class="line">pid                     #nginx启动时的pid</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">worker_connections    #每个进程允许最大连接数</span><br><span class="line">use                   #nginx使用的内核模型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用 nginx 的 http 服务，在配置文件 nginx.conf 中的 http 区域内，配置无数个 server ，每一个 server 对应这一个虚拟主机或者域名。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">... ...        #后面再详细介绍 http 配置项目</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen <span class="number">80</span>                          #监听端口;</span><br><span class="line">        server_name localhost              #地址</span><br><span class="line">        </span><br><span class="line">        location / &#123;                       #访问首页路径</span><br><span class="line">            root /xxx/xxx/index.<span class="property">html</span>       #默认目录</span><br><span class="line">            index index.<span class="property">html</span> index.<span class="property">htm</span>     #默认文件</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        error_page  <span class="number">500</span> <span class="number">504</span>   /50x.<span class="property">html</span>    #当出现以上状态码时从新定义到50x.<span class="property">html</span></span><br><span class="line">        location = /50x.<span class="property">html</span> &#123;             #当访问50x.<span class="property">html</span>时</span><br><span class="line">            root /xxx/xxx/html             #50x.<span class="property">html</span> 页面所在位置</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    server &#123;</span><br><span class="line">        ... ... </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 server 可以出现多个 location ，我们对不同的访问路径进行不同情况的配置。</p>
<p>我们再来看看 http 的配置详情</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">sendfile  on                  #高效传输文件的模式 一定要开启</span><br><span class="line">keepalive_timeout   <span class="number">65</span>        #客户端服务端请求超时时间</span><br><span class="line">log_format  main   <span class="variable constant_">XXX</span>        #定义日志格式 代号为main</span><br><span class="line">access_log  /usr/local/access.<span class="property">log</span>  main     #日志保存地址 格式代码 main</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是 nginx 一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。</p>
<p><img src="/2022/08/30/Nginx/nginx_2.png" alt="Nginx/nginx_2.png"></p>
]]></content>
      <categories>
        <category>部署知识</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket</title>
    <url>/2022/08/30/WebSocket/</url>
    <content><![CDATA[<p>##WebSocket<br>###一、什么是websocket<br>WebSocket是HTML5下一种新的协议（websocket协议本质上是一个基于tcp的协议）<br>它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的<br>Websocket是一个持久化的协议<br>###二、websocket的原理<br>websocket约定了一个通信的规范，通过一个握手的机制，客户端和服务器之间能建立一个类似tcp的连接，从而方便它们之间的通信<br>在websocket出现之前，web交互一般是基于http协议的短连接或者长连接<br>websocket是一种全新的协议，不属于http无状态协议，协议名为”ws”<br>###三、websocket与http的关系<br><img src="/2022/08/30/WebSocket/websocket1.png" alt="WebSocket/websocket1.png"><br>####相同点：</p>
<p>都是基于tcp的，都是可靠性传输协议<br>都是应用层协议<br>####不同点：<br>WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息<br>HTTP是单向的<br>WebSocket是需要浏览器和服务器握手进行建立连接的<br>而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接<br>####联系：<br>WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的<br>####总结（总体过程）：<br>首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；</p>
<p>然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；</p>
<p>最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。<br>###四，websocket解决的问题<br>####1.http存在的问题<br>http是一种无状态协议，每当一次会话完成后，服务端都不知道下一次的客户端是谁，需要每次知道对方是谁，才进行相应的响应，</p>
<p>因此本身对于实时通讯就是一种极大的障碍<br>http协议采用一次请求，一次响应，每次请求和响应就携带有大量的header头，对于实时通讯来说，解析请求头也是需要一定的时间，因此，效率也更低下</p>
<p>最重要的是，需要客户端主动发，服务端被动发，也就是一次请求，一次响应，不能实现主动发送<br>####2.long poll(长轮询)<br>对于以上情况就出现了http解决的第一个方法——长轮询</p>
<p>基于http的特性，简单点说，就是客户端发起长轮询，如果服务端的数据没有发生变更，会 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询<br>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，实现了“伪·长连接”</p>
<p>张三取快递的例子，张三今天一定要取到快递，他就一直站在快递点，等待快递一到，立马取走</p>
<p>从例子上来看有个问题：<br>假如有好多人一起在快递站等快递，那么这个地方是否足够大，（抽象解释：需要有很高的并发，同时有很多请求等待在这里）<br>总的来看：<br>推送延迟。服务端数据发生变更后，长轮询结束，立刻返回响应给客户端。</p>
<p>服务端压力。长轮询的间隔期一般很长，例如 30s、60s，并且服务端 hold 住连接不会消耗太多服务端资源。</p>
<p>####3.Ajax轮询<br>基于http的特性，简单点说，就是规定每隔一段时间就由客户端发起一次请求，查询有没有新消息，如果有，就返回，如果没有等待相同的时间间隔再次询问</p>
<p>优点是解决了http不能实时更新的弊端，因为这个时间很短，发起请求即处理请求返回响应，把这个过程放大n倍，本质上还是request = response</p>
<p>举个形象的例子（假设张三今天有个快递快到了，但是张三忍耐不住，就每隔十分钟给快递员或者快递站打电话，询问快递到了没，每次快递员就说还没到，等到下午张三的快递到了，but，快递员不知道哪个电话是张三的，（可不是只有张三打电话，还有李四，王五），所以只能等张三打电话，才能通知他，你的快递到了）</p>
<p>从例子上来看有两个问题：</p>
<p>假如说，张三打电话的时间间隔为10分钟，当他收到快递前最后一次打电话，快递员说没到，他刚挂掉电话，快递入库了（就是到了），那么等下一次时间到了，张三打电话知道快递到了，那么这样的通讯算不算实时通讯？很显然，不算，中间有十分钟的时间差，还不算给快递员打电话的等待时间（抽象的解释：每次request的请求时间间隔等同于十分钟，请求解析相当于等待）<br>假如说张三所在的小区每天要收很多快递，每个人都采取主动给快递员打电话的方式，那么快递员需要以多快的速度接到，其他人打电话占线也是问题（抽象解释：请求过多，服务端响应也会变慢）</p>
<p>总的来看，Ajax轮询存在的问题：<br>推送延迟。</p>
<p>服务端压力。配置一般不会发生变化，频繁的轮询会给服务端造成很大的压力。</p>
<p>推送延迟和服务端压力无法中和。降低轮询的间隔，延迟降低，压力增加；增加轮询的间隔，压力降低，延迟增高</p>
<p>####4.websocket的改进<br>一旦WebSocket连接建立后，后续数据都以帧序列的形式传输。在客户端断开WebSocket连接或Server端中断连接前，不需要客户端和服务端重新发起连接请求。在海量并发及客户端与服务器交互负载流量大的情况下，极大的节省了网络带宽资源的消耗，有明显的性能优势，且客户端发送和接受消息是在同一个持久连接上发起，实现了“真·长链接”，实时性优势明显。<br><img src="/2022/08/30/WebSocket/websocket_2.png" alt="WebSocket/websocket_2.png"><br>####WebSocket有以下特点：</p>
<p>是真正的全双工方式，建立连接后客户端与服务器端是完全平等的，可以互相主动请求。</p>
<p>而HTTP长连接基于HTTP，是传统的客户端对服务器发起请求的模式。</p>
<p>HTTP长连接中，每次数据交换除了真正的数据部分外，服务器和客户端还要大量交换HTTP header，信息交换效率很低。</p>
<p>Websocket协议通过第一个request建立了TCP连接之后，之后交换的数据都不需要发送 HTTP header就能交换数据，这显然和原有的HTTP协议有区别所以它需要对服务器和客户端都进行升级才能实现（主流浏览器都已支持HTML5）</p>
]]></content>
      <categories>
        <category>通讯协议</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法</title>
    <url>/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>##二叉树递归遍历的三种姿势<br>以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。按照顺序规则的不同，遍历方式有以下四种：</p>
<ul>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
<li>层次遍历</li>
</ul>
<p>按照实现方式的不同，遍历方式又可以分为以下两种：</p>
<ul>
<li>递归遍历（先、中、后序遍历）</li>
<li>迭代遍历（层次遍历）</li>
</ul>
<p>遍历的可能顺序也不过三种：</p>
<ul>
<li>根结点 -&gt; 左子树 -&gt; 右子树</li>
<li>左子树 -&gt; 根结点 -&gt; 右子树</li>
<li>左子树 -&gt; 右子树 -&gt; 根结点</li>
</ul>
<p>上述三个遍历顺序，就分别对应了二叉树的先序遍历、中序遍历和后序遍历规则。</p>
<p>在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。<br>所谓的“先序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。</p>
<p><strong>先序遍历的编码实现：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有遍历函数的入参都是树的根结点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">preorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">preorder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>中序遍历：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 所有遍历函数的入参都是树的根结点对象</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">inorder</span>(root.<span class="property">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>后序遍历：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">postorder</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="comment">// 递归边界，root 为空</span></span><br><span class="line">    <span class="keyword">if</span>(!root) &#123;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 递归遍历左子树 </span></span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">left</span>)  </span><br><span class="line">    <span class="comment">// 递归遍历右子树  </span></span><br><span class="line">    <span class="title function_">postorder</span>(root.<span class="property">right</span>)</span><br><span class="line">    <span class="comment">// 输出当前遍历的结点值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;当前遍历的结点值是：&#x27;</span>, root.<span class="property">val</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##数组的应用<br>###Map 的妙用——两数求和问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例: 给定 nums = [<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>], target = <span class="number">9</span></span><br><span class="line">因为 nums[<span class="number">0</span>] + nums[<span class="number">1</span>] = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span> 所以返回 [<span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>大家以后做算法题的时候，要有这样的一种本能：当发现自己的代码里有两层循环时，先反思一下，能不能用空间换时间，把它优化成一层循环。</p>
<p>大家记住一个结论：几乎所有的求和问题，都可以转化为求差问题。 这道题就是一个典型的例子，通过把求和问题转化为求差问题，事情会变得更加简单。</p>
<p><strong>我们可以在遍历数组的过程中，增加一个 Map 来记录已经遍历过的数字及其对应的索引值。然后每遍历到一个新数字的时候，都回到 Map 里去查询 targetNum 与该数的差值是否已经在前面的数字中出现过了</strong>。若出现过，那么答案已然显现，我们就不必再往下走了。</p>
<p><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_6.png" alt="img_6.png"><br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_7.png" alt="img_7.png"><br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_8.png" alt="img_8.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> twoSum = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里我用对象来模拟 map 的能力</span></span><br><span class="line">    <span class="keyword">const</span> diffs = &#123;&#125;</span><br><span class="line">    <span class="comment">// 缓存数组长度</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++) &#123;</span><br><span class="line">        <span class="comment">// 判断当前值对应的 target 差值是否存在（是否已遍历过）</span></span><br><span class="line">        <span class="keyword">if</span>(diffs[target-nums[i]]!==<span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="comment">// 若有对应差值，那么答案get！</span></span><br><span class="line">            <span class="keyword">return</span> [diffs[target - nums[i]], i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若没有对应差值，则记录当前值</span></span><br><span class="line">        diffs[nums[i]]=i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>###强大的双指针法<br>####合并两个有序数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例: 输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>], n = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>这道题没有太多的弯弯绕绕，标准解法就是双指针法。首先我们定义两个指针，各指向两个数组生效部分的尾部：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_9.png" alt="img_9.png"><br>每次只对指针所指的元素进行比较。取其中较大的元素，把它从 nums1 的末尾往前面填补：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_10.png" alt="img_10.png"></p>
<p>由于 nums1 的有效部分和 nums2 并不一定是一样长的。我们还需要考虑其中一个提前到头的这种情况：</p>
<ul>
<li><p>如果提前遍历完的是 nums1 的有效部分，剩下的是 nums2。那么这时意味着 nums1 的头部空出来了，直接把 nums2 整个补到 nums1 前面去即可。</p>
</li>
<li><p>如果提前遍历完的是 nums2，剩下的是 nums1。由于容器本身就是 nums1，所以此时不必做任何额外的操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125; Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化两个指针的指向，初始化 nums1 尾部索引k</span></span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>, k = m + n - <span class="number">1</span></span><br><span class="line">    <span class="comment">// 当两个数组都没遍历完时，指针同步移动</span></span><br><span class="line">    <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 取较大的值，从末尾往前填补</span></span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">            nums1[k] = nums1[i] </span><br><span class="line">            i-- </span><br><span class="line">            k--</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[k] = nums2[j] </span><br><span class="line">            j-- </span><br><span class="line">            k--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// nums2 留下的情况，特殊处理一下 </span></span><br><span class="line">    <span class="keyword">while</span>(j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        nums1[k] = nums2[j]  </span><br><span class="line">        k-- </span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p><em>个人总结：</em>*</p>
</li>
<li><p>nums1后面留出足够塞nums2的length（3）的空位</p>
</li>
<li><p>两个数组尾部比较，6&gt;3,6塞在nums1最后，nums2往前进一位，nums1总长度往前进一位</p>
</li>
<li><p>继续尾部比较，5&gt;3，6塞在nums1倒数第二位，nums2往前进一位，nums1总长度往前进一位</p>
</li>
<li><p>继续尾部比较，2&lt;3，3塞在nums1倒数第三位，nums1往前进一位，nums1总长度往前进一位<br>…以此类推</p>
</li>
</ul>
<p>####三数求和问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">真题描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = <span class="number">0</span> ？请你找出所有满足条件且不重复的三元组。</span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例： 给定数组 nums = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>]， 满足要求的三元组集合为： [ [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>] ]</span><br></pre></td></tr></table></figure>
<p>思路：</p>
<p>把求和问题变成求差问题——固定其中一个数，在剩下的数中寻找是否有两个数和这个固定数相加是等于0的</p>
<p><strong>双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。</strong>否则双指针根本无法帮助我们缩小定位的范围，压根没有意义。因此这道题的第一步是将数组排序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> nums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后，对数组进行遍历，每次遍历到哪个数字，就固定哪个数字。然后把左指针指向该数字后面一个坑里的数字，把右指针指向数组末尾，让左右指针从起点开始，向中间前进：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_11.png" alt="img_11.png"></p>
<p>每次指针移动一次位置，就计算一下两个指针指向数字之和加上固定的那个数之后，是否等于0。如果是，那么我们就得到了一个目标组合；否则，分两种情况来看：</p>
<ul>
<li><p>相加之和大于0，说明右侧的数偏大了，右指针左移</p>
</li>
<li><p>相加之和小于0，说明左侧的数偏小了，左指针右移</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> threeSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="comment">// 用于存放结果数组</span></span><br><span class="line">    <span class="keyword">let</span> res = [] </span><br><span class="line">    <span class="comment">// 给 nums 排序</span></span><br><span class="line">    nums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 缓存数组长度</span></span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 注意我们遍历到倒数第三个数就足够了，因为左右指针会遍历后面两个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len-<span class="number">2</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 左指针 j</span></span><br><span class="line">        <span class="keyword">let</span> j=i+<span class="number">1</span> </span><br><span class="line">        <span class="comment">// 右指针k</span></span><br><span class="line">        <span class="keyword">let</span> k=len-<span class="number">1</span>   </span><br><span class="line">        <span class="comment">// 如果遇到重复的数字，则跳过</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]===nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;k) &#123;</span><br><span class="line">            <span class="comment">// 三数之和小于0，左指针前进</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                j++</span><br><span class="line">               <span class="comment">// 处理左指针元素重复的情况</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i]+nums[j]+nums[k]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">// 三数之和大于0，右指针后退</span></span><br><span class="line">                k--</span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 处理右指针元素重复的情况</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                    k--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 得到目标数字组合，推入结果数组</span></span><br><span class="line">                res.<span class="title function_">push</span>([nums[i],nums[j],nums[k]])</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 左右指针一起前进</span></span><br><span class="line">                j++  </span><br><span class="line">                k--</span><br><span class="line">               </span><br><span class="line">                <span class="comment">// 若左指针元素重复，跳过</span></span><br><span class="line">                <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[j]===nums[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    j++</span><br><span class="line">                &#125;  </span><br><span class="line">               </span><br><span class="line">               <span class="comment">// 若右指针元素重复，跳过</span></span><br><span class="line">               <span class="keyword">while</span>(j&lt;k&amp;&amp;nums[k]===nums[k+<span class="number">1</span>]) &#123;</span><br><span class="line">                    k--</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果数组</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>什么时候你需要联想到对撞指针？<br>这里我给大家两个关键字——“有序”和“数组”。<br>没错，见到这两个关键字，立刻把双指针法调度进你的大脑内存。普通双指针走不通，立刻想对撞指针！</p>
<p>##字符串的应用<br>###判断一个字符串是否是回文字符串<br><strong>重点：对称性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">真题描述：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。</span><br></pre></td></tr></table></figure>
<p>思路：字符串题干中若有“回文”关键字，那么做题时脑海中一定要冒出两个关键字——对称性 和 双指针。这两个工具一起上，足以解决大部分的回文字符串衍生问题。</p>
<p>回到这道题上来，我们首先是初始化两个指针，一个指向字符串头部，另一个指向尾部：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_12.png" alt="img_12.png"><br>如果两个指针所指的字符恰好相等，那么这两个字符就符合了回文字符串对对称性的要求，跳过它们往下走即可。如果两个指针所指的字符串不等，比如这样：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_13.png" alt="img_13.png"><br>那么就意味着不对称发生了，意味着这是一个可以“删掉试试看”的操作点。我们可以分别对左指针字符和右指针字符尝试进行“跳过”，看看区间在 [left+1, right] 或 [left, right-1] 的字符串是否回文。如果是的话，那么就意味着如果删掉被“跳过”那个字符，整个字符串都将回文：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_14.png" alt="img_14.png"><br>比如说这里我们跳过了 b，[left+1, right] 的区间就是 [2, 2]，它对应 c 这个字符，单个字符一定回文。这样一来，删掉 b 之后，左右指针所指的内部区间是回文的，外部区间也是回文的，可以认为整个字符串就是一个回文字符串了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> validPalindrome = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存字符串的长度</span></span><br><span class="line">    <span class="keyword">const</span> len = s.<span class="property">length</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i、j分别为左右指针</span></span><br><span class="line">    <span class="keyword">let</span> i=<span class="number">0</span>, j=len-<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当左右指针均满足对称时，一起向中间前进</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;j&amp;&amp;s[i]===s[j]) &#123;</span><br><span class="line">        i++ </span><br><span class="line">        j--</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试判断跳过左指针元素后字符串是否回文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isPalindrome</span>(i+<span class="number">1</span>,j)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试判断跳过右指针元素后字符串是否回文</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_">isPalindrome</span>(i,j-<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 工具方法，用于判断字符串是否回文</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">isPalindrome</span>(<span class="params">st, ed</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(st&lt;ed) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[st] !== s[ed]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            st++</span><br><span class="line">            ed--</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认返回 false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>##链表的应用<br>###链表的合并</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">真题描述：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。 </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例： 输入：<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>, <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span> 输出：<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>做链表处理类问题，大家要把握住一个中心思想——处理链表的本质，是处理链表结点之间的指针关系。<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_15.png" alt="img_15.png"></p>
<p>这根针每次钻进扣子眼儿之前，要先比较一下它眼前的两个扣子，选择其中值较小的那个，优先把它串进去。一次串一个，直到所有的扣子都被串进一条线为止（下图中红色箭头表明穿针的过程与方向）：</p>
<p><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_16.png" alt="img_16.png"><br>同时我们还要考虑 l1 和 l2 两个链表长度不等的情况：若其中一个链表已经完全被串进新链表里了，而另一个链表还有剩余结点，考虑到该链表本身就是有序的，我们可以直接把它整个拼到目标链表的尾部。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l1</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">l2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> mergeTwoLists = <span class="keyword">function</span>(<span class="params">l1, l2</span>) &#123;</span><br><span class="line">  <span class="comment">// 定义头结点，确保链表可以被访问到</span></span><br><span class="line">  <span class="keyword">let</span> head = <span class="keyword">new</span> <span class="title class_">ListNode</span>()</span><br><span class="line">  <span class="comment">// cur 这里就是咱们那根“针”</span></span><br><span class="line">  <span class="keyword">let</span> cur = head</span><br><span class="line">  <span class="comment">// “针”开始在 l1 和 l2 间穿梭了</span></span><br><span class="line">  <span class="keyword">while</span>(l1 &amp;&amp; l2) &#123;</span><br><span class="line">      <span class="comment">// 如果 l1 的结点值较小</span></span><br><span class="line">      <span class="keyword">if</span>(l1.<span class="property">val</span>&lt;=l2.<span class="property">val</span>) &#123;</span><br><span class="line">          <span class="comment">// 先串起 l1 的结点</span></span><br><span class="line">          cur.<span class="property">next</span> = l1</span><br><span class="line">          <span class="comment">// l1 指针向前一步</span></span><br><span class="line">          l1 = l1.<span class="property">next</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// l2 较小时，串起 l2 结点</span></span><br><span class="line">          cur.<span class="property">next</span> = l2</span><br><span class="line">          <span class="comment">// l2 向前一步</span></span><br><span class="line">          l2 = l2.<span class="property">next</span></span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// “针”在串起一个结点后，也会往前一步</span></span><br><span class="line">      cur = cur.<span class="property">next</span> </span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理链表不等长的情况</span></span><br><span class="line">  cur.<span class="property">next</span> = l1!==<span class="literal">null</span>?<span class="attr">l1</span>:l2</span><br><span class="line">  <span class="comment">// 返回起始结点</span></span><br><span class="line">  <span class="keyword">return</span> head.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###链表结点的删除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">真题描述：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>将需要删除的目标结点的前驱结点 next 指针往后指一格：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_17.png" alt="img_17.png"><br>判断两个元素是否重复，由于此处是已排序的链表，我们直接判断前后两个元素值是否相等即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 设定 cur 指针，初始位置为链表第一个结点</span></span><br><span class="line">    <span class="keyword">let</span> cur = head;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span> &amp;&amp; cur.<span class="property">next</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 若当前结点和它后面一个结点值相等（重复）</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 删除靠后的那个结点（去重）</span></span><br><span class="line">            cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若不重复，继续遍历</span></span><br><span class="line">            cur = cur.<span class="property">next</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>###删除问题的延伸——dummy 结点登场</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">真题描述：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span></span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>咱们要做的事情变成了把前驱和后继一起删掉，前面两个值为1的结点要一起狗带才行，起始结点直接变成了第三个：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_18.png" alt="img_18.png"><br>其实在链表题中，经常会遇到这样的问题：链表的第一个结点，因为没有前驱结点，导致我们面对它无从下手。这时我们就可以用一个 dummy 结点来解决这个问题。</p>
<p>回到这道题上来，我们首先要做的就是定义一个 dummy 结点，指向链表的起始位置：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_19.png" alt="img_19.png"><br>这样一来，如果想要删除两个连续重复的值为 1 的结点，我们只需要把 dummy 结点的 next 指针直接指向 2：<br><img src="/2022/08/30/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/img_20.png" alt="img_20.png"></p>
<p>注意：由于重复的结点可能不止一个两个，我们这里需要用一个 while 循环来反复地进行重复结点的判断和删除操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">ListNode</span>&#125; <span class="variable">head</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">ListNode</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="comment">// 极端情况：0个或1个结点，则不会重复，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(!head || !head.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dummy 登场</span></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>() </span><br><span class="line">    <span class="comment">// dummy 永远指向头结点</span></span><br><span class="line">    dummy.<span class="property">next</span> = head   </span><br><span class="line">    <span class="comment">// cur 从 dummy 开始遍历</span></span><br><span class="line">    <span class="keyword">let</span> cur = dummy </span><br><span class="line">    <span class="comment">// 当 cur 的后面有至少两个结点时</span></span><br><span class="line">    <span class="keyword">while</span>(cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="comment">// 对 cur 后面的两个结点进行比较</span></span><br><span class="line">        <span class="keyword">if</span>(cur.<span class="property">next</span>.<span class="property">val</span> === cur.<span class="property">next</span>.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="comment">// 若值重复，则记下这个值</span></span><br><span class="line">            <span class="keyword">let</span> val = cur.<span class="property">next</span>.<span class="property">val</span></span><br><span class="line">            <span class="comment">// 反复地排查后面的元素是否存在多次重复该值的情况</span></span><br><span class="line">            <span class="keyword">while</span>(cur.<span class="property">next</span> &amp;&amp; cur.<span class="property">next</span>.<span class="property">val</span>===val) &#123;</span><br><span class="line">                <span class="comment">// 若有，则删除</span></span><br><span class="line">                cur.<span class="property">next</span> = cur.<span class="property">next</span>.<span class="property">next</span> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 若不重复，则正常遍历</span></span><br><span class="line">            cur = cur.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回链表的起始结点</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Vue的数据绑定方式</title>
    <url>/2022/08/30/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>###Vue的数据绑定方式<br>Vue.js是采用数据劫持结合发布者-订阅者模式，利用Object.defineProperty劫持对象的访问器,在属性值发生变化时我们可以获取变化,从而进行进一步操作。</p>
<p>###实现MVVM的双向绑定</p>
<ul>
<li><strong>Observer</strong>：实现一个数据监听器Observer,能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li>
<li><strong>Compile</strong>：实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li>
<li><strong>Watcher</strong>:实现一个Watcher，作为连接Observer和Compile的桥梁，它将接收到的Observer产生的数据变化,并根据Compile提供的指令进行视图渲染,使得数据变化促使视图变化</li>
</ul>
<p><img src="/2022/08/30/Vue%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E6%96%B9%E5%BC%8F/img_5.png" alt="img_5.png"></p>
<p>我们看到，虽然Vue运用了数据劫持，但是依然离不开发布订阅的模式，之所以在系列2做了Event Bus的实现,就是因为我们不管在学习一些框架的原理还是一些流行库（例如Redux、Vuex）,基本上都离不开发布订阅模式,而Event模块则是此模式的经典实现</p>
<p>####1、我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 用于储存订阅者并发布消息</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">id</span> = uid++;</span><br><span class="line">      <span class="comment">// 储存订阅者的数组</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subs</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class="line">    <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="title class_">Dep</span>.<span class="property">target</span>.<span class="title function_">addDep</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加订阅者</span></span><br><span class="line">    <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> sub.<span class="title function_">update</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class="line">  <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>####2、现在我们需要实现监听者(Observer),用于监听属性值的变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听者,监听对象属性值的变化</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">value</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value;</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(value).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> <span class="title function_">defineReactive</span>(value, key, value[key]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">defineReactive</span>(<span class="params">obj, key, val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">    <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">    <span class="keyword">let</span> chlidOb = <span class="title function_">observe</span>(val);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">get</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class="line">        <span class="comment">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class="line">        <span class="comment">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Dep</span>.<span class="property">target</span>) &#123;</span><br><span class="line">          dep.<span class="title function_">depend</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">set</span>: <span class="function"><span class="params">newVal</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">        val = newVal;</span><br><span class="line">        <span class="comment">// 对新值进行监听</span></span><br><span class="line">        chlidOb = <span class="title function_">observe</span>(newVal);</span><br><span class="line">        <span class="comment">// 通知所有订阅者，数值被改变了</span></span><br><span class="line">        dep.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="comment">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Observer</span>(value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>####3、我们需要实现一个订阅者(Watcher)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, expOrFn, cb</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">depIds</span> = &#123;&#125;; <span class="comment">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm; <span class="comment">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cb</span> = cb; <span class="comment">// 当数据更新时想要做的事情</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">expOrFn</span> = expOrFn; <span class="comment">// 被订阅的数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = <span class="variable language_">this</span>.<span class="title function_">get</span>(); <span class="comment">// 维护更新之前的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">run</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addDep</span>(<span class="params">dep</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class="line">    <span class="comment">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">depIds</span>.<span class="title function_">hasOwnProperty</span>(dep.<span class="property">id</span>)) &#123;</span><br><span class="line">      dep.<span class="title function_">addSub</span>(<span class="variable language_">this</span>);</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">depIds</span>[dep.<span class="property">id</span>] = dep;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">run</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="variable language_">this</span>.<span class="title function_">get</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (val !== <span class="variable language_">this</span>.<span class="property">val</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">val</span> = val;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cb</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>.<span class="property">vm</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">_data</span>[<span class="variable language_">this</span>.<span class="property">expOrFn</span>];</span><br><span class="line">    <span class="comment">// 置空，用于下一个Watcher使用</span></span><br><span class="line">    <span class="title class_">Dep</span>.<span class="property">target</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现Compile</strong></p>
<p>compile主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图，如图所示： img3</p>
<p>因为遍历解析的过程有多次操作dom节点，为提高性能和效率，会先将vue实例根节点的el转换成文档碎片fragment进行解析编译操作，解析完成，再将fragment添加回原来的真实dom节点中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Compile</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$el</span> = <span class="variable language_">this</span>.<span class="title function_">isElementNode</span>(el) ? el : <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">$el</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$fragment</span> = <span class="variable language_">this</span>.<span class="title function_">node2Fragment</span>(<span class="variable language_">this</span>.<span class="property">$el</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">init</span>();</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">$el</span>.<span class="title function_">appendChild</span>(<span class="variable language_">this</span>.<span class="property">$fragment</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Compile</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">	<span class="attr">init</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">this</span>.<span class="title function_">compileElement</span>(<span class="variable language_">this</span>.<span class="property">$fragment</span>); &#125;,</span><br><span class="line">    <span class="attr">node2Fragment</span>: <span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>(), child;</span><br><span class="line">        <span class="comment">// 将原生节点拷贝到fragment</span></span><br><span class="line">        <span class="keyword">while</span> (child = el.<span class="property">firstChild</span>) &#123;</span><br><span class="line">            fragment.<span class="title function_">appendChild</span>(child);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>compileElement方法将遍历所有节点及其子节点，进行扫描解析编译，调用对应的指令渲染函数进行数据渲染，并调用对应的指令更新函数进行绑定，详看代码及注释说明：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Compile</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">	<span class="comment">// ... 省略</span></span><br><span class="line">	<span class="attr">compileElement</span>: <span class="keyword">function</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> childNodes = el.<span class="property">childNodes</span>, me = <span class="variable language_">this</span>;</span><br><span class="line">        [].<span class="property">slice</span>.<span class="title function_">call</span>(childNodes).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> text = node.<span class="property">textContent</span>;</span><br><span class="line">            <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;	<span class="comment">// 表达式文本</span></span><br><span class="line">            <span class="comment">// 按元素节点方式编译</span></span><br><span class="line">            <span class="keyword">if</span> (me.<span class="title function_">isElementNode</span>(node)) &#123;</span><br><span class="line">                me.<span class="title function_">compile</span>(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.<span class="title function_">isTextNode</span>(node) &amp;&amp; reg.<span class="title function_">test</span>(text)) &#123;</span><br><span class="line">                me.<span class="title function_">compileText</span>(node, <span class="title class_">RegExp</span>.<span class="property">$1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历编译子节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">childNodes</span> &amp;&amp; node.<span class="property">childNodes</span>.<span class="property">length</span>) &#123;</span><br><span class="line">                me.<span class="title function_">compileElement</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">compile</span>: <span class="keyword">function</span>(<span class="params">node</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> nodeAttrs = node.<span class="property">attributes</span>, me = <span class="variable language_">this</span>;</span><br><span class="line">        [].<span class="property">slice</span>.<span class="title function_">call</span>(nodeAttrs).<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">attr</span>) &#123;</span><br><span class="line">            <span class="comment">// 规定：指令以 v-xxx 命名</span></span><br><span class="line">            <span class="comment">// 如 &lt;span v-text=&quot;content&quot;&gt;&lt;/span&gt; 中指令为 v-text</span></span><br><span class="line">            <span class="keyword">var</span> attrName = attr.<span class="property">name</span>;	<span class="comment">// v-text</span></span><br><span class="line">            <span class="keyword">if</span> (me.<span class="title function_">isDirective</span>(attrName)) &#123;</span><br><span class="line">                <span class="keyword">var</span> exp = attr.<span class="property">value</span>; <span class="comment">// content</span></span><br><span class="line">                <span class="keyword">var</span> dir = attrName.<span class="title function_">substring</span>(<span class="number">2</span>);	<span class="comment">// text</span></span><br><span class="line">                <span class="keyword">if</span> (me.<span class="title function_">isEventDirective</span>(dir)) &#123;</span><br><span class="line">                	<span class="comment">// 事件指令, 如 v-on:click</span></span><br><span class="line">                    compileUtil.<span class="title function_">eventHandler</span>(node, me.<span class="property">$vm</span>, exp, dir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="comment">// 普通指令</span></span><br><span class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.<span class="property">$vm</span>, exp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令处理集合</span></span><br><span class="line"><span class="keyword">var</span> compileUtil = &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="keyword">function</span>(<span class="params">node, vm, exp</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">bind</span>(node, vm, exp, <span class="string">&#x27;text&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">    <span class="attr">bind</span>: <span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> updaterFn = updater[dir + <span class="string">&#x27;Updater&#x27;</span>];</span><br><span class="line">        <span class="comment">// 第一次初始化视图</span></span><br><span class="line">        updaterFn &amp;&amp; <span class="title function_">updaterFn</span>(node, vm[exp]);</span><br><span class="line">        <span class="comment">// 实例化订阅者，此操作会在对应的属性消息订阅器中添加了该订阅者watcher</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, exp, <span class="keyword">function</span>(<span class="params">value, oldValue</span>) &#123;</span><br><span class="line">        	<span class="comment">// 一旦属性值有变化，会收到通知执行此更新函数，更新视图</span></span><br><span class="line">            updaterFn &amp;&amp; <span class="title function_">updaterFn</span>(node, value, oldValue);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新函数</span></span><br><span class="line"><span class="keyword">var</span> updater = &#123;</span><br><span class="line">    <span class="attr">textUpdater</span>: <span class="keyword">function</span>(<span class="params">node, value</span>) &#123;</span><br><span class="line">        node.<span class="property">textContent</span> = <span class="keyword">typeof</span> value == <span class="string">&#x27;undefined&#x27;</span> ? <span class="string">&#x27;&#x27;</span> : value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...省略</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里通过递归遍历保证了每个节点及子节点都会解析编译到，包括了<code>&#123;&#123;&#125;&#125;</code>表达式声明的文本节点。指令的声明规定是通过特定前缀的节点属性来标记，如&lt;span v-text=”content” other-attr中v-text便是指令，而other-attr不是指令，只是普通的属性。 监听数据、绑定更新函数的处理是在compileUtil.bind()这个方法中，通过new Watcher()添加回调来接收数据变化的通知</p>
<p>####4、那么我们最后完成Vue,将上述方法挂载在Vue上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">     <span class="comment">// 简化了$options的处理</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">$options</span> = options;</span><br><span class="line">     <span class="comment">// 简化了对data的处理</span></span><br><span class="line">     <span class="keyword">let</span> data = (<span class="variable language_">this</span>.<span class="property">_data</span> = <span class="variable language_">this</span>.<span class="property">$options</span>.<span class="property">data</span>);</span><br><span class="line">     <span class="comment">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">keys</span>(data).<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">_proxy</span>(key));</span><br><span class="line">     <span class="comment">// 监听数据</span></span><br><span class="line">     <span class="title function_">observe</span>(data);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class="line">   $watch(expOrFn, cb) &#123;</span><br><span class="line">     <span class="keyword">new</span> <span class="title class_">Watcher</span>(<span class="variable language_">this</span>, expOrFn, cb);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">_proxy</span>(<span class="params">key</span>) &#123;</span><br><span class="line">     <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="variable language_">this</span>, key, &#123;</span><br><span class="line">       <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">get</span>: <span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="property">_data</span>[key],</span><br><span class="line">       <span class="attr">set</span>: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="variable language_">this</span>.<span class="property">_data</span>[key] = val;</span><br><span class="line">       &#125;,</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>个人总结：</strong></p>
<ul>
<li>Observer监听者监听对象属性的变化，用Object.defineProperty，get的时候<strong>添加订阅者</strong>，set的时候<strong>通知所有订阅者，数值被改变了</strong></li>
</ul>
<p><strong>Object.defineProperty的缺陷</strong></p>
<ul>
<li>无法监听数组变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> demo = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line"><span class="attr">list</span>: [<span class="number">1</span>],</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">demo.<span class="property">list</span>.<span class="title function_">push</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = arr =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line"><span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">li.<span class="property">textContent</span> = arr[i];</span><br><span class="line">fragment.<span class="title function_">appendChild</span>(li);</span><br><span class="line">&#125;</span><br><span class="line">list.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数组,每次数组变化则触发渲染函数,然而...无法监听</span></span><br><span class="line">demo.$watch(<span class="string">&#x27;list&#x27;</span>, <span class="function"><span class="params">list</span> =&gt;</span> <span class="title function_">render</span>(list));</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(</span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(demo.<span class="property">list</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="number">5000</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
<li>只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择</li>
</ul>
<p><strong>Proxy</strong></p>
<ul>
<li>Proxy可以直接监听对象而非属性，Proxy直接可以劫持整个对象,并返回一个新对象<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">&#x27;text&#x27;</span>) &#123;</span><br><span class="line">      input.<span class="property">value</span> = value;</span><br><span class="line">      p.<span class="property">innerHTML</span> = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  newObj.<span class="property">text</span> = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>Proxy可以直接监听数组的变化<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染列表</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Render</span> = &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  <span class="attr">init</span>: <span class="keyword">function</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">      li.<span class="property">textContent</span> = arr[i];</span><br><span class="line">      fragment.<span class="title function_">appendChild</span>(li);</span><br><span class="line">    &#125;</span><br><span class="line">    list.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 我们只考虑了增加的情况,仅作为示例</span></span><br><span class="line">  <span class="attr">change</span>: <span class="keyword">function</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span><br><span class="line">    li.<span class="property">textContent</span> = val;</span><br><span class="line">    list.<span class="title function_">appendChild</span>(li);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数组</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="keyword">new</span> <span class="title class_">Proxy</span>(arr, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">&#x27;length&#x27;</span>) &#123;</span><br><span class="line">      <span class="title class_">Render</span>.<span class="title function_">change</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Render</span>.<span class="title function_">init</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push数字</span></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  newArr.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的</li>
<li>Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。</li>
</ul>
]]></content>
      <categories>
        <category>前端笔记</category>
      </categories>
  </entry>
</search>
